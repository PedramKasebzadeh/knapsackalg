---
title: "Knapsack package"
author: "Roshni , Mariano and Pedram"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
  #code_folding: show
vignette: >
  %\VignetteIndexEntry{Knapsack Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette summarizes three functions of Knapsack package and gives examples on how to use them.
The 3 functions are,

1. Brute force algorithm
2. Dynamic algorithm
3. Greedy approximation algorithm

These functions takes a data.frame x with two variables v and w and returns the maximum knapsack value and which elements (rows in the data.frame).

### Brute force algorithm

```{r}
brute_force_knapsack <- function(x,W)
{
  stopifnot(is.data.frame(x))
  stopifnot(W>0)
  value <- 0
  elem <-c()
  
  for(i in 1:(2^nrow(x)-1))
  {wsum <- 0
  vsum <- 0
  loop <-c()
  binary <- intToBits(i)
  
  for(j in 1:length(binary))
  {if( binary[j] == TRUE )
  {
    wsum <- wsum + x[j,1]
    vsum <- vsum + x[j,2]
    loop <- c(loop,j)
  }
    
  }
  
  if(vsum > value && wsum <= W)
  {value<-vsum 
  elem<-loop}}
  
  return(list(value=round(unname(value)),elements=elem))
}
```

#### Run time for 16 objects

```{r}
ptm <- proc.time()
n <- 16
knapsack_objects <- data.frame(
  w=sample(1:4000, size = n, replace = TRUE),
  v=runif(n = n, 0, 10000))
brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000)
proc.time() - ptm
```

### Dynamic algorithm

```{r}
knapsack_dynamic <- function(x, W){
  stopifnot(is.data.frame(x) == TRUE)
  stopifnot(is.numeric(W) == TRUE)
  n <- nrow(x)
  w <- x[[1]]  #weights
  v <- x[[2]]  #values
  capacity <- W     #capacity of knapsack
  elem <- c()
  m <- matrix(0,nrow = n+1,ncol = capacity+1)
 
  #to return the max value 
  for (i in 2:n){
    for (j in 1:capacity){
      if (j > w[i]) 
        m[i, j] <- max(m[i-1, j-w[i]] + v[i], m[i-1, j])
      else 
        m[i,j] <- m[i-1, j]
    }
  }
  
  val <- m[i, j]
  value <- round(val)
  
  #to print the elements
  while(capacity>0 && n-1>0){
    if(m[n,capacity]!=m[n-1,capacity]){
      elem<-c(elem,n)
      capacity<-capacity-w[n]
      elements <- sort(elem)
    }
    n<-n-1
  }
  return(list("value"=value,"elements"=elements))
  
}
```

#### Run time for 500 objects

```{r}
ptm <- proc.time()
n <- 500
knapsack_objects <- data.frame(
  w=sample(1:4000, size = n, replace = TRUE),
  v=runif(n = n, 0, 10000))
knapsack_dynamic(x = knapsack_objects[1:12,], W = 2000)
proc.time() - ptm
```

### Greedy approximation algorithm

```{r}
greedy_knapsack <- function(x,W){
  stopifnot(is.data.frame(x))
  stopifnot(W>0)
  df <- transform(x, c= v/w )
  df<- df[order(df$c,decreasing = TRUE),]
  w8  <- vector()
  j=0
  Val <- vector()
  elements <- vector()
  while(sum(w8) <= W)
  {
    w8 <-  append(w8,df$w[j])
    Val <- append(Val,df$v[j])
    j <- j+1
    
  }
  
  if(sum(w8)> W)
  { 
    w8 <- head(w8,-1)
    Val <- head(Val,-1)
  }
  Val
  elements <- append(elements,which(x$w  %in% w8))
  results <- list("value"= sum(Val),"elements"=elements)
  return(results)
  
}
```

#### Run time for 1000000 objects

```{r}
ptm <- proc.time()
n <- 1000000
knapsack_objects <- data.frame(
  w=sample(1:4000, size = n, replace = TRUE),
  v=runif(n = n, 0, 10000))
greedy_knapsack(x = knapsack_objects[1:1200,], W = 2000)
proc.time() - ptm
```

### Examples

#### For brute force method

```{r}
#brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
#brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000)
```


#### For dynamic approach

```{r}
#knapsack_dynamic(x = knapsack_objects[1:8,], W = 3500)
#knapsack_dynamic(x = knapsack_objects[1:12,], W = 2000)
```

#### For greedy approach
```{r}
#greedy_knapsack(x = knapsack_objects[1:800,], W = 3500)
#greedy_knapsack(x = knapsack_objects[1:1200,], W = 2000)
```


```{r echo=FALSE}
#library(tictoc)
#tic()   # refer https://www.r-bloggers.com/5-ways-to-measure-running-time-of-r-code/
#knapsack_dynamic(x = knapsack_objects[1:8,], W = 2000)
#toc()
```


### See also

1. "Description of Knapsack problem"
([via](https://en.wikipedia.org/wiki/Knapsack_problem))

2. "Pseudocode to implement dynamic algorithm"
([via](https://en.wikipedia.org/wiki/Knapsack_problem#0.2F1_knapsack_problem))

3. "To implement greedy approach"
([via](https://en.wikipedia.org/wiki/Knapsack_problem#Greedy_approximation_algorithm))

4. "To measure the run time of code chunk"
([via](https://www.r-bloggers.com/5-ways-to-measure-running-time-of-r-code/))